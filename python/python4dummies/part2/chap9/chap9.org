#+TITLE: Les erreurs ? Quelles erreurs ?
#+AUTHOR: Laurent Garnier

La plupart du temps, un code d'une certaine complexité comporte des
erreurs. Si votre application se bloque soudain sans raison
apparente, il y a une erreur. Voir appraître un message obscur est un
autre type d'erreur. Cependant, nombre d'erreurs peuvent aussi se
produire sans que vous ne receviez la moindre notification. Par
exemple, une application pourrait effectuer les mauvais calculs sur
une série de valeurs qui lui ont été fournies, ce qui donnerait un
résultat erroné. Dans ce cas, vous pourriez ne jamais vous en
apercevoir, jusqu'à ce que quelqu'un vous en avertisse ou que vous
soyez pris d'un sérieux doute. Les erreurs ont aussi besoin de
cohérence. Vous pourriez par exemple en déclencher une dans certaines
circonstances, disons par exemple quand le réseau est surchargé, et
pas dans d'autres.  En bref, des peuvent survenir dans toutes sortes
de situations et pour toutes sortes de raisons. Ce chapitre se
consacre donc à cette importante question et il vous explique comment
réagir lorsque votre application rencontre des erreurs. 

Il n'y a rien de surprenant à ce que des erreurs surgissent. Les
applications sont écrites par des humains, et les humains font des
erreurs. La plupart des développeurs appellent ces erreurs des
/exceptions/, dans le sens où il s'agit d'exception à la
règle. Puisque des exceptions se produisent dans les applications,
vous devez les détecter et y réagir dès que possible. Détecter et
traiter une exception relève de ce que l'on appelle un /gestionnaire
d'erreur/, ou encore un /gestionnaire d'exception/ (on parle aussi de
système de gestion d'exception, ou d'erreur). Pour détecter
correctement des erreurs, vous avez besoin de savoir quelle peut en
être la cause, et pourquoi elles se produisent. Pour cela, vous devez
/intercepter/ l'exception, autrement dit l'examiner et si possible en
faire quelque chose. Nous découvrirons donc aussi comment gérer des
exceptions dans vos propres applications. 

Parfois, votre code détecte une erreur dans l'application. Lorsque
cela se produit, vous devez /lever/ (raise) ou /propager/ (throw) une
exception. Vous pouvez rencontrer ces deux termes (avec des variantes)
pour désigner à peu près la même chose : votre code a rencontré une
erreur qu'il ne peut pas gérer, et il passe une information sur cette
erreur à une autre pièce de code, le gestionnaire d'exception, qui va
interpréter, traiter et avec de la chance réparer cette erreur. Même
si Python possède des tas de messages génériques qui couvrent la
plupart des situations, certaines sont tout à fait spéciales, ce qui
peut vous obliger à utiliser des messages d'erreur personnalisés (sans
compter que ceux de Python sont tous en anglais). Par exemple, vous
pourriez avoir besoin de fournir un support particulier pour une
application de base de données, chose que Python ne couvre pas par
défaut. Il est important de savoir quand il est nécessaire de traiter
les exceptions spéciales, de manière à ce que chaque partie de
l'application sache comment gérer l'exception. Nous reviendrons sur
tous ces sujets dans ce chapitre. 

* Savoir pourquoi Python ne vous comprend pas

  Les langages de programmation comme les ordinateurs sont des choses
  inanimées. Ils n'ont aucun état d'âme, aucun désir, aucune volonté
  personnelle. De plus, ils ne pensent pas. Ils acceptent à peu près
  littéralement ce que les programmeurs leurs disent de faire. Et
  c'est tout. Et c'est en même temps parfois très frustrant quand on a
  soudain l'impression (fausse) que le langage de programmation ou
  l'ordinateur semble vaquer à ses propres occupations sans se soucier
  du reste...

  Ni Python ni l'ordinateur ne sont capables de comprendre ce que vous
  voulez faire lorsque vous tapez du code. Ils suivent vos
  instructions en les prenant au pied de la lettre. Par exemple, vous
  n'avez /pas/ demandé à Python de supprimer un fichier de données, à
  moins qu'une certaine situation absurde se produise. Mais, si vous
  n'avez pas très clairement explicité les choses, il n'est pas
  impossible que Python supprime le fichier de données, situation
  absurde ou pas. Lorsque ce genre de chose se produit, on dit
  généralement que l'aplication /bug/. Mais, en réalité, il s'agit
  simplement d'erreurs de codage qui pourraient être détectées et
  corrigées en faisant appel à un /débogueur/. 

  Des erreurs se produisent bien souvent dans des situations où le
  développeur fait certaines suppositions qui se révèlent
  fausses. Bien entendu, ceci comprend les réactions des utilisateurs,
  qui ne se soucient probablement pas du tout de l'extrême niveau de
  soin que vous avez pris pour écrire une application
  parfaite. L'utilisateur entre une mauvaise donnée. Python, qui n'est
  en rien concerné par ces problématiques, traite cette donnée, même
  si votre intention initiale était toute autre. Python ne comprend
  rien à ces questions existentielles. Il effectue son travail en
  fonction des règles que vous avez définies. Ce qui impique qu'il
  vous appartient, et uniquement à vous, de créer des règles qui
  protègent les utilisateurs d'eux-mêmes. 

  Python n'est ni proactif ni créatif. Ce sont des qualités qui
  n'existent que chez le développeur. Si une erreur réseau se produit,
  ou si l'utilisateur fait quelque chose d'inattendu, Python est
  incapable de créer une solution afin de résoudre ce problème. Il ne
  fait qu'exécuter du code. Si vous n'avez rien de prévu pour gérer
  une telle situation, il est probable que l'application plantera sans
  autre forme de procès (et éventuellement les données de
  l'utilisateur avec). Bien entendu, un développeur ne peut pas
  anticiper tous les cas possibles. C'est pourquoi la plupart des
  applications complexes comportent des erreurs (en l'occurrence, il
  s'agirait d'une erreur par omission). 

  Ne vous bercez d'aucune illusion : écrire un code parfaitement à
  l'épreuve des balles est juste une idée absurde. Vous devez être
  totalement convaincu qu'un certain nombre de /bugs/ se produiront
  dans la durée de vie de vos applications, que la nature et les
  utilisateurs continueront à effectuer des actions auxquelles
  personne n'avait pensé, et que même le meilleur programmeur du monde
  ne peut pas anticiper toutes les conditions d'erreur possible. En
  d'autres termes, supposez /toujours/ que votre application est
  sujette à des erreurs qui vont provoquer des exceptions. C'est en
  raisonnant ainsi que vous pourrez créer des applications non pas
  parfaites, mais plus efficaces et plus fiables. 

* Prendre en considération les sources d'erreurs
  
  Vous pourriez peut-être deviner les sources d'erreurs potentielles
  de votre application en lisant dans le marc de café, mais vous vous
  doutez bien que cela risque de ne pas être très efficace. En fait,
  les erreurs se répartissent en catégories bien définies qui vous
  aident, du moins dans une certaine mesure, à mieux comprendre quand
  et où elles sont susceptibles de se produire. Les deux catégories
  principales sont les suivantes : 
  + les erreurs qui surgissent à un moment spécifique 
  + les erreurs qui sont d'un type spécifique
  
  
  Les sections qui suivent explicitent ces notions. Le concept
  général, c'est que vous avez besoin de réfléchir à la classification
  des erreurs de manière à commencer à les trouver et les réparer dans
  vos applications avant même qu'elles ne deviennent un problème. 

** Erreurs surgissant à un moment spécifique  

   Ce type d'erreur se décompose en deux catégories principales : 
   + au moment de la compilation
   + au moment de l'exécution

   
   Dans tous les cas, votre application va mal. Voyons donc cela de
   plus près.

** Erreur de compilation   

   Une telle erreur se produit au moment où vous demandez à Python
   d'exécuter votre application. Avant même de commencer, il doit
   interpréter le code et le transcrire dans une forme compréhensible
   par l'ordinateur. L'ordinateur, de son côté, ne connaît qu'une
   langue extrêmement binaire, et de surcroît liée à son processeur et
   à son architecture. Si les instructions que vous avez saisies sont
   mal formées, ou si des informations indispensables manquent, Python
   ne peut pas effectuer la conversion dans le langage de la
   machine. Il renvoie donc une erreur que vous devez réparer pour que
   l'application puisse être lancée. 

   Fort heureusement, les erreurs de ce type sont les plus faciles à
   localiser et à fixer. Du fait que l'application ne peut même pas se
   lancer, l'utilisateur ne voit jamais ce genre d'erreur. C'est à
   vous de résoudre le problème en corrigeant le code erroné. 

   L'apparence d'une erreur de compilation devrait attirer votre
   attention sur le fait qu'il existe d'autres fautes de frappe ou
   d'autres omissions dans le code. Il est toujours bénéfique de
   contrôler les lignes de code environnantes afin de s'assurer qu'il
   n'y a pas d'autres problèmes potentiels qui pourraient ne se
   révéler qu'au moment de l'exécution.

** Erreur d'exécution

   C'est fait. Python a compilé votre code et lancé l'application. Et
   c'est à partir de là que peut se produire une erreur
   d'exécution. De telles erreurs peuvent avoir des causes variées, et
   certaines sont plus difficiles à cerner que d'autres. Vous savez
   qu'une erreur d'exécution s'est produite si l'application cesse
   brusquement de fonctionner en affichant une exception, ou encore si
   l'utilisateur se plaint de recevoir une sortie erronée, ou bien
   encore de l'instabilité de l'application. 

   Toutes les erreurs d'exécution ne produisent pas une
   exception. Certaines peuvent se traduire par un gel du
   fonctionnement, par une sortie qui semble erratique, ou encore par
   des données endommagées. Certaines peuvent aussi affecter d'autres
   applications, voire même la plate-forme sur laquelle le code est
   exécuté Votre responsabilité est donc engagée en tant que
   développeur !

   De nombreuses erreurs d'exécution sont provoquées par des fautes de
   frappe, voire des oublis de saisie. Par exemple, mal orthographier
   le nom d'une variable empêchera Python de placer la bonne valeur au
   bon endroit (de ce point de vue, la confusion entre majuscule et
   minuscule est rédhibitoire). Oublier un argument facultatif, mais
   nécessaire dans l'appel à une méthode peut aussi provoquer des
   problèmes. En général, il est possible de localiser de telles
   erreurs en faisant appel aux services d'un débogueur, ou plus
   simplement en relisant votre code ligne par ligne. 

   Les erreurs d'exécution peuvent également être provoquées par des
   événements extérieurs non associés à votre code. Par exemple,
   l'utilisateur entre une information incorrecte et que l'application
   ne sait pas traiter, ce qui provoque une exception. Un problème sur
   le réseau peut tout aussi bien rendre des données
   inaccessibles. Parfois aussi, c'est matériel de l'ordinateur qui a
   une défaillance, ce qui provoque une erreur non repérable. Tous ces
   exemples forment des /erreurs par omission/, que votre application
   pourrait être en mesure de récupérer si votre application contient
   le code nécessaire à cela. Il est important de prendre en compte
   ces différents cas lorsque vous vous concevez votre application. 

** Distinguer les types d'erreurs   

   Connaître les types d'erreurs vous aide à comprendre où rechercher
   d'éventuels problèmes dans une application. Les exceptions
   fonctionnent comme de nombreuses autres choses de la vie. Par
   exemple, vous savez que les appareils électroniques ne marchent pas
   sans une source d'alimentation électrique. Si vous essayez
   d'allumer votre téléviseur, et qu'il ne se passe rien, la première
   chose à faire est de vérifier que son cordon d'alimentation est
   correctement branché dans la prise de contact. 

   Comprendre les types d'erreurs vous aide à localiser celles-ci plus
   vite, plus tôt et plus efficacement. Et donc aussi à commettre
   moins d'erreurs avec les erreurs. Les meilleurs développeurs savent
   bien qu'il est toujours plus facile de corriger les problèmes
   pendant le développement d'une application que lorsqu'elle est en
   service, car les utilisateurs sont par essence impatients, et ils
   veulent que les problèmes soient réparés immédiatement et
   correctement. De plus, en prenant cette question à bras le corps
   dès le début du cycle de développement limite la quantité de code à
   vérifier et à corriger. 

   Toute l'astuce consiste à savoir où regarder. Python (comme la
   plupart des autres langages de programmation) distingue ces types
   d'erreurs : 
   + syntaxiques
   + sémantiques
   + logiques

   Les sections qui suivent vont préciser cela en procédant par ordre
   de difficulté croissante.

*** Erreurs de syntaxe
    
    Chaque fois que vous faites une faute de frappe quelconque, vous
    commettez une erreur de syntaxe. Bien souvent, celles-ci sont
    plutôt faciles à détecter, car le code ne s'exécute tout
    simplement pas. L'interpréteur peut même vous guider en affichant
    un message d'erreur qui vous signale l'emplacement de
    l'erreur. Cependant, certaines erreurs de syntaxe sont très
    délicates à découvrir. Ainsi, Python est extrêmement sensible à la
    capitalisation des caractères. Il suffit donc de mettre une
    majuscule à la place d'une minuscule (ou l'inverse) dans une seule
    occurrence d'une variable pour que celle-ci ne fonctionne pas
    comme elle le devrait. Localiser ce genre de faute peut parfois
    être un véritable challenge.

    La plupart des erreurs de syntaxe sont délcenchées lors de la
    compilation, et l'interpréteur les pointe pour vous. Dans ce cas,
    la correction est facilitée, puisque l'interpréteur vous dit
    généralement ce qu'il faut modifier, et ce avec une précision
    considérable. Même si ce n'est pas le cas, les erreurs de syntaxe
    empêchent l'application de fonctionner correctement, et vous le
    retrouvez au cours des phases de test. Peu d'erreurs de ce type
    devraient persister au-delà, du moins si vous avez testé
    complètement votre application.

*** Erreurs sémantiques

    Lorsque vous créez une boucle qui s'exécute plus de fois qu'il
    n'est nécessaire, vous ne recevez en général aucune information de
    l'application vous signalant qu'il y a une erreur. Du point de vue
    de l'application, tout semble normal, mais des boucles
    supplémentaires peuvent provoquer toutes sortes d'erreurs dans les
    données. Vous n'avez pas fait de faute de frappe, vous avez
    provoqué sans le vouloir une /erreur sémantique/.

    Les erreurs sémantiques sont dues au fait que l'idée sous-jacente
    à une série d'étapes est erronée. Le résultat est incorrect, même
    si le code semble se dérouler normalement. De telles erreurs sont
    parfois ardues à localiser, et un bon débogueur est bien souvent
    votre meilleur allié.

*** Erreurs de logique

    Certains ne font pas la distinction entre erreurs sémantiques et
    erreurs de logique, mais ils ont tort. Une erreur sémantique se
    produit lorsque le code est pour l'essentiel correct, mais que
    l'implémentation est mauvaise (comme une boucle qui s'exécute une
    fois de trop). Les erreurs de logique sont dues à un défaut de
    raisonnement du développeur. Cela se produit souvent lors de
    l'emploi incorrect d'un opérateur relationnel ou logique. Mais
    elles peuvent aussi être dues à bien d'autres causes. Par exemple,
    un programmeur pense que les données qu'il traite sont toujours
    stockées sur le disque dur local. Et l'application risque donc
    fort de se comporter d'une manière inhabituelle si elle essaie de
    charger des données à partir d'un disque réseau. 

    Les erreurs logiques sont assez difficiles à corriger, puisque le
    problème ne se trouve pas dans le code, mais dans la conception
    qui a amené à l'écrire. C'est le processus mental de développement
    qui est fautif. Et donc la personne qui est responsable de cette
    erreur est la moins bien placée pour la localiser. Avoir une
    seconde paire d'yeux (disons, un partenaire avisé) est donc
    toujours une bonne idée. De même, formaliser avec précision les
    spécifications d'une application aidera beaucoup, car cela
    permettra de mieux suivre la logique cachée derrière les tâches
    que cette application doit réaliser. 

* Intercepter les exceptions

  D'un point de vue général, un utilisateur ne devrait jamais voir un
  message ou une boîte de dialoguqe dont l'affichage est provoqué par
  une exception. L'application devrait toujours intercepter cette
  exception, et la traiter avant qu'elle n'arrive jusqu'à
  l'utilisateur. Bien entendu, le monde réel n'est pas aussi simple
  que cela, et certaines exceptions arrivent à passer à travers les
  mailles du filet. Pour autant, le but est d'essayer d'intercepter
  toute exception potentielle lors du développement d'une
  application. C'est le sujet des sections qui suivent. 

** Comprendre les exceptions intégrées à Python
   
   Python est accompagné d'une grande quantité d'exceptions
   prédéfinies, bien plus que vous ne pourriez l'imaginer. Vous pouvez
   en voir la liste en consultant l'adresse
   [[https://docs.python.org/3.7/library/exceptions.html]]. La
   documentation partage la liste des exceptions en plusieurs
   catégories. En voici un rapide aperçu : 
   + Classes de base :: elles fournissent les blocs de constructions
        essentiels pour les autres exceptions (par exemple,
        l'exception judicieusement appelée =Exception=). Vous pouvez
        cependant voir directement certaines d'entre elles lorsque
        vous travaillez avec une application (par exemple,
        =ArithmeticError=).
   + Exceptions dites concrètes :: certaines applications peuvent
        rencontrer des erreurs difficiles peuvent rencontrer des
        erreurs difficiles à résoudre parce qu'il n'existe pas de bon
        procédé pour les traiter, ou parce qu'elles signalent un
        événement que l'application doit gérer elle-même. Par exemple,
        si un système vient à manquer de mémoire, Python génère une
        exception =MemoryError=. Résoudre ce problème est difficile,
        car il n'est pas toujours possible de libérer de la mémoire
        occupée par d'autres programmes. Lorsque l'utilisateur appuie
        sur une touche d'interruption (comme Ctrl+C), Python génère
        une exception =KeyboardInterrupt=. C'est bien à l'application
        de réagir face à cette situation avant de passer à d'autres
        tâches. 
   + Exceptions de l'OS :: le système d'exploitation peut générer des
        erreurs que Python passe ensuite à votre application. Si, par
        exemple, celle-ci tente d'ouvrir un fichier qui n'existe pas,
        le système génère une erreur =FileNotFoundError=. 
   + Avertissements :: Python essaie aussi parfois de vous avertir
                       d'un événement inattendu, ou d'actions qui
                       pourraient par la suite engendrer des
                       erreurs. Par exemple, une tentative
                       inappropriée d'utiliser une certaine ressource,
                       comme une icône, va déclencher l'exception
                       =ResourceWarning=. Il s'agit bien d'un simple
                       avertissement, pas d'une erreur. Vous n'êtes
                       donc pas verbalisé. Vous pouvez l'ignorer, mais
                       vous devez savoir qu'une erreur peut survenir
                       plus tard.


** Gérer les exceptions de base

   Pour gérer les exceptions, vous devez indiquer votre intention à
   Python puis fournir le code qui va effectuer ce genre de
   tâche. Vous avez pour cela de nombreuses méthodes à votre
   disposition. Nous allons dans ce qui suit commencer par le plus
   simple pour aller vers des méthodes plus complexes, mais aussi plus
   souples et plus puissantes. 

*** Gérer une unique exception

    #+BEGIN_SRC python
      try:
	  value = int(input("Tapez un nombre entre 1 et 10 : "))
      except ValueError:
	  print("Vous devez taper un nombre entre 1 et 10 !")
      else:

	  if (value > 0) and (value <= 10):
	      print("Vous avez tapé : ", value)
	  else:
	      print("La valeur que vous avez tapée est incorrecte !")
    #+END_SRC

    Le code qui est placé à l'intérieur du bloc =try= gère ses propres
    exceptions. Dans ce cas, cette gestion signifie obtenir de
    l'utilisateur une saisie via l'appel à =int(input())=. Si une
    exception se produit à l'extérieur de ce bloc, elle ne sera pas
    gérée par celui-ci. Bien entendu, du coup, la tentation pourrait
    être grande de placer tout le code dans un seul bloc =try=. Mais
    ce serait en fait une très mauvaise idée. Un bon gestionnaire
    d'exception doit être petit et spécifique à un certain problème
    potentiel pour qu'il soit plus facile de localiser et donc de
    corriger celui-ci.

    Le bloc =except= recherche une exception spécifique, dans ce cas
    =ValueError=. Si l'utilisateur provoque une exception =ValueError=
    en tapant par exemple *Bonjour* au lieu d'une valeur numérique, ce
    bloc d'exception particulier est exécuté. Si l'utilisateur génère
    une autre exception, le bloc =except= ne pourra pas la gérer.

    Le bloc =except= contient tout le code qui est exécuté si le bloc
    de code =try= génère une exception. Tout le reste est lié à =try=,
    car vous ne voulez exécuter ce bloc que si l'utilisateur saisit
    une valeur correcte, autrement dit un nombre compris entre 1
    et 10.

*** Utiliser la clause except sans exception

    Vous pouvez créer dans Python un gestionnaire d'exception
    générique, et donc sans spécifier une exception particulière. Dans
    la plupart des cas, il y a quelques bonnes raisons pour fournir
    une exception spécifique :
    + éviter de masquer une exception que vous n'avez pas prise en
      compte lors de la conception de l'application
    + s'assurer que d'autres savent précisément quelles exceptions
      votre application va gérer
    + gérer les exceptions correctement en utilisant un code adapté à
      chacune d'elle


    Cependant, vous avez parfois besoin de quelque chose de plus
    générique, par exemple si vous utilisez une bibliothèque externe
    ou si vous interagissez avec un service externe. 

    #+BEGIN_SRC python
      try:
	  value = int(input("Tapez un nombre entre 1 et 10 : "))
      except:
	  print("Vous devez taper un nombre entre 1 et 10 !")
      else:

	  if (value > 0) and (value <= 10):
	      print("Vous avez tapé : ", value)
	  else:
	      print("La valeur que vous avez tapée est incorrecte !")
    #+END_SRC


*** Exceptions et arguments     

    La plupart des exceptions ne fournissent pas d'arguments
    (c'est-à-dire une liste de valeurs que vous pouvez tester pour
    obtenir des informations supplémentaires). Une exception est ou
    n'est pas, là est la question. Cependant, quelques rares
    exceptions fournissent des arguments. Vous les verrez plus loin
    dans ce livre. Ces arguments vous en disent plus sur l'exception
    et ils fournissent les détails dont vous avez besoin pour corriger
    le problème. 

    Pour couvrir tout de même l'éventail des possibilités, cette
    section vous propose un exemple simple qui génère une exception
    avec un argument. 

    #+BEGIN_SRC python
      import sys

      try:
	  File = open('myfile.txt')
      except IOError as e:
	  print("Erreur lors de l'ouverture du fichier ! \r\n" +
		"Numéro de l'erreur : {0}\r\n".format(e.errno) +
		"Texte de l'erreur : {0}".format(e.strerror))
      else:
	  print("Le fichier a bien été ouvert.")
	  File.close();    
    #+END_SRC

* Obtenir la liste des arguments d'une exception    

  La liste des éventuels arguments varie selon l'exception et de ce
  que fournit l'appelant. Il n'est pas toujours facile de se faire une
  idée de ce que vous pouvez obtenir lorsque vous recherchez des
  informations complémentaires. Une manière de gérer cette question
  consiste à afficher simplement toute cette liste en utilisant un
  code tel que celui-ci :
  #+BEGIN_SRC python
    import sys

    try:
	File = open('myfile.txt')
    except IOError as e:
	for Arg in e.args:
	    print(Arg)
    else:
	print("Le fichier a bien été ouvert.")
	File.close();
  #+END_SRC
  
  La propriété =args= contient toujours une liste des arguments de
  l'exception au format chaîne de caractères. Vous pouvez utiliser une
  simple boucle =for= pour imprimer chaque argument. Le seul problème
  avec cette approche est que vous n'obtenez pas le nom de ces
  arguments. Vous savez donc ce qu'ils contiennent, mais pas comment
  les appeler.

  Une méthode plus complexe consiste à afficher à la fois le nom et la
  valeur des arguments. C'est ce que fait le code suivant :
  #+BEGIN_SRC python
    import sys

    try:
	File = open('myfile.txt')
    except IOError as e:
	for Entry in dir(e):
	    if (not Entry.startswith("_")):
		try:
		    print(Entry, " = ", e.__getattribute__(Entry))
		except AttributeError:
		    print("Attribut ", Entry, " non accessible.")
	    else:
		print("Le fichier a bien été ouvert.")
		File.close();
  #+END_SRC


  Ici, vous commencez par obtenir une liste des attributs associés à
  l'objet argument de l'erreur en utilisant la fonction =dir()=. La
  sortie produite par cette fonction est une liste de chaînes de
  caractères contenant les noms des attributs affichables. Seuls les
  arguments dont le nom ne débute pas par un trait de soulignement
  (=_=) contiennent des informations utiles sur
  l'exception. Cependant, même certaines de ces entrées sont
  inaccessibles. C'est pourquoi vous devez placer la sortie de
  =print()= dans un second bloc =try...except=.

  Le nom de l'attribut est simple à traiter, car il est contenu dans
  =Entry=. Pour obtenir la valeur correspondante, vous devez faire
  appel à la fonction =__getattribute__= en lui fournissant le nom de
  l'attribut concerné. Lorsque vous exécutez ce code, vous voyez donc
  à la fois le nom et la valeur de chacun des attributs de l'argument
  pour cette exception particulière. Dans ce cas, la sortie produite
  par l'application se présenterait ainsi : 

  #+BEGIN_SRC python
    args = (2, 'No such file or directory')
    Attribut characters_written non accessible.
    errno = 2
    filename = myfile.txt
    filename2 = None
    strerror = No such file or directory
    wneerror = None
    with_traceback = <built-in method_with_traceback of
    FileNotFoundError object at 0x031810D0>
  #+END_SRC

** Gérer de multiples exceptions avec une seule clause except  

   La plupart des applications sont capables de générer plusieurs
   exceptions pour une même ligne de code. Cette situation a déjà été
   rencontrée dans ce chapitre. La manière de gérer une telle
   situation dépend de ce que vous cherchez à obtenir, du type des
   exceptions et du degré de compétence éventuel de vos
   utilisateurs. Avec des utilisateurs plus ou moins novices, il est
   souvent préférable de leur dire que l'application a rencontré une
   erreur non récupérable, et d'enregistrer les détails dans un
   fichier journal placé dans le dossier de l'application ou bien dans
   une unité en réseau, ou encore envoyée vers un nuage Internet. 

   Utiliser une clause =except= unique pour gérer de multiples
   exceptions ne marche que s'il est possible de satisfaire aux
   besoins de tous les types d'exceptions à l'intérieur d'une source
   commune d'actions. Sinon, cela signifie que chaque exception doit
   être traitée individuellement. Les étapes qui suivent illustrent
   cette méthode de travail l
   #+BEGIN_SRC python
     try:
	 Value = int(input("Tapez un nombre entre 1 et 10 : "))
     except (ValueError, KeyboardInterrupt):
	 print("Vous devez taper un nombre entre 1 et 10 !")
     else:

	 if (Value > 0) and (Value <= 10):
	     print("Vous avez tapé : ", Value)
	 else:
	     print("La valeur que vous avez tapée est incorrecte !")
   #+END_SRC

** Gérer des exceptions multiples avec plusieurs clauses except    

   Lorsque vous travaillez avec des exceptions multiples, il est
   généralement préférable de placer chacune d'entre elles dans sa
   propre clause =except=. Cette approche vous permet de fournir un
   système de gestion personnalisé pour chaque exception, ce qui
   permet notamment à l'utilisateur de savoir plus précisément où se
   situe le problème. Bien entendu, cette approche demande également
   plus de travail. 

   #+BEGIN_SRC python
     try:
	 Value = int(input("Tapez un nombre entre 1 et 10 : "))
     except ValueError:
	 print("Vous devez taper un nombre entre 1 et 10 !")
     except KeyboardInterrupt:
	 print("Vous avez appuyé sur Ctrl+C !")
     else:

	 if (Value > 0) and (Value <= 10):
	     print("Vous avez tapé : ", Value)
   #+END_SRC

** Gérer des exceptions en allant du plus spécifique au moins spécifique   

   Une stratégie de gestion des exceptions consiste à fournir des
   clauses =except= spécifiques pour toutes les exceptions connues, et
   des clauses =except= génériques pour toutes les exceptions non
   prévisibles ou inconnues. La documentation en ligne de Python
   détaille la hiérarchie des exceptions (voyez l'adresse
   [[https://docs.python.org/3.7/library/exceptions.html]]). Vous y
   remarquez par exemple que =BaseException= est l'exception de plus
   haut niveau. La plupart des exceptions sont dérivées de
   =Exception=. Si vous travaillez sur des opérations mathématiques,
   vous pouvez utiliser l'exception générique =ArithmeticError=, ou la
   plus spécifique =ZeroDivisionError=.

   Python évalue les clauses =except= dans l'ordre où elles
   apparaissent dans le fichier du code source. La première rencontrée
   est examinée en premier, la seconde vient après, et ainsi de
   suite. Les étapes qui suivent vous aident à examiner un exemple
   destiné à démontrer l'importance qu'il y a à utiliser un ordre
   correct pour le traitement des exceptions.

   #+BEGIN_SRC python
     try:
	 Value1 = int(input("Tapez le premier nombre : "))
	 Value2 = int(input("Tapez le second nombre : "))
	 Output = Value1 / Value2
     except ValueError:
	 print("Vous devez taper un nombre entier !")
     except KeyboardInterrupt:
	 print("Vous avez appuyé sur Ctrl+C !")
     except ArithmeticError:
	 print("Une erreur de math non définie s'est produite.")
     except ZeroDivisionError:
	 print("Tentative de division par zéro !")
     else:
	 print(Output)
    
   #+END_SRC

* Imbriquer des exceptions   

  Vous aurez parfois besoin de placer un gestionnaire d'exception à
  l'intérieur d'un autre. Ce processus est appelé
  /imbrication/. Lorsque vous procédez ainsi, Python essaie d'abord de
  trouver un gestionnaire d'exception dans les niveaux les plus bas,
  puis il remonte vers les couches extérieures. Vous pouvez empiler
  autant de niveaux que vous le souhaitez pour rendre votre code aussi
  sûr qu'il est possible. 

  L'une des raisons les plus courantes d'utilisation de cette
  technique est la construction d'une partie de code dans laquelle
  vous demandez à l'utilisateur de saisir quelque chose. Vous placez
  ensuite la réponse obtenue dans une boucle pour vous assurer que
  vous avez bien obtenu l'information demandée. C'est ce qu'illustrent
  les étapes qui suivent :

  #+BEGIN_SRC python
    TryAgain = True

    while TryAgain:

	try:
	    Value = int(input("Tapez un nombre entier : "))
	except ValueError:
	    print("Vous devez taper un nombre entier !")

	    try:
		DoOver = input("Essayer à nouveau (o/n) ? ")
	    except:
		print("OK, à la prochaine fois !")
		TryAgain = False
	    else:
		if (str.upper(DoOver) == "N"):
		    TryAgain = False

	except KeyboardInterrupt:
	    print("Vous avez appuyé sur Ctrl+C !")
	    print("À la prochaine fois !")
	    TryAgain = False
	else:
	    print(Value)
	    TryAgain = False
  #+END_SRC


  Ce code commence par créer une boucle de saisie. Cette méthode est
  en fait assez courante, car vous ne voulez pas que l'application se
  termine chaque fois qu'il y a une erreur de saisie. Cette boucle est
  simplifiée, et, normalement, vous devriez créer une fonction séparée
  pour ce code.

  Lorsque la boucle démarre, l'application demande à l'utilisateur de
  taper un nombre entier. Il peut s'agir de n'importe quelle valeur
  entière. Si l'utilisateur entre un nombre qui n'est pas un entier,
  ou encore s'il appuie sur Ctrl + C, Cmd + C ou une autre combinaison
  de touches d'interruption, le code de gestion des exceptions se
  déclenche. Sinon, l'application affiche la valeur fournie par
  l'utilisateur, et la variable =TryAgain= est mise à la valeur
  =False=, ce qui termine la boucle. 

  Une exception =ValueError= peut se produire lorsque l'utilisateur
  fait une erreur. Comme vous ne connaissez pas la raison de celle-ci,
  vous devez demander à l'utilisateur s'il veut faire une nouvelle
  tentative. Bien entendu, répéter cette procédure pourrait générer
  une autre exception. Le bloc de code intérieur =try...except= gère
  cette seconde saisie. 

  Notez l'emploi de la fonction =str.upper()= à la suite de la
  question posée à l'utilisateur. Elle permet de répondre par o ou par
  O sans avoir à distinguer entre minuscule et majuscule. Chaque fois
  que vous demandez à l'utilisateur de répondre de cette manière,
  convertir ce qu'il tape en majuscule est toujours une bonne idée,
  car cela vous permet de n'effectuer qu'une seule comparaison et
  réduit le nombre d'erreurs potentielles. 

  L'exception =KeyboardInterrupt= affiche deux messages, puis quitte
  automatiquement la boucle en affcetant à la variable =TryAgain= la
  valeur =False=. Cette exception ne se produit que si l'utilisateur
  appuie sur une certaine combinaison de touches destinée à terminer
  l'application. Dans ce cas, cela signifie très certainement que
  l'utilisateur ne veut pas continuer. 

* Lever des exceptions  

  Jusqu'ici, les exemples de ce chapitre ont réagi à des
  exceptions. Quelque chose se produit, et l'application fournit le
  support d'un gestionnaire d'exception pour traiter cet
  événement. Cependant, dans certaines circonstances, vous ne savez
  pas comment gérer tel ou tel événement problématique au cours du
  processus de développement. Par exemple, vous ne pouvez pas traiter
  une erreur à un certain niveau, et vous devez donc la transmettre à
  un autre niveau. Dit autrement, il existe des situations dans
  lesquelles votre application doit générer une exception. On appelle
  souvent cela /lever une exception/ (ou parfois /propager une
  exception/). Les sections qui suivent décrivent quelques scénarii
  courants dans lesquels vous avez à lever des exceptions de manière
  spécifique.

** Lever des exceptions lors de conditions exceptionnelles

   Cet exemple vous montre comment lever une exception simple, ne
   réclamant rien de spécial.

   #+BEGIN_SRC python
     try:
	 raise ValueError
     except ValueError:
	 print("Exception ValueError!")
   #+END_SRC

   Evidemment, vous n'allez jamais écrire du code tel que
   celui-ci. Mais ce petit exemple vous montre comment les choses se
   passent au niveau le plus basique. Dans ce cas, l'appel à =raise=
   apparaît à l'intérieur d'un bloc =try...except=. Il fournit
   simplement le nom de l'exception qui a été levée (ou
   propagée). Vous pouvez également fournir des arguments dans la
   sortie pour fournir des informations complémentaires. 

   Remarquez que le bloc =try...except= ne contient pas de clause
   =else=, simplement parce qu'il n'y a rien de particulier à faire
   après l'appel. Même si cette forme est rare, elle est possible. La
   clause =else= est optionnelle, même si vous devriez pratiquement
   toujours en ajouter au moins une.

** Passer des informations sur une erreur à l'appelant   

   Python fournit un système de gestion des erreurs exceptionnellement
   souple en ce que vous pouvez passer des informations à l'/appelant/
   (le code qui appelle votre code) quelle que soit l'exception
   concernée. Bien entendu, cet appelant peut ne pas savoir que cette
   information est disponible, ce qui pose d'autres questions. Si vous
   travaillez avec le code de quelqu'un d'autre et que vous ne savez
   pas comment les choses se passent, vous pouvez toujours faire appel
   à la technique décrite plus haut dans l'encadré << Obtenir la liste
   des arguments d'une exception >>. 

   Vous pouvez vous demander s'il est possible de communiquer de
   meilleures informations lorsque vous travaillez avec l'exception
   =ValueError=, plutôt qu'avec une exception fournie nativement par
   Python. Les étapes qui suivent vous montrent comment modifier la
   sortie pour obtenir un tel résultat. 

   #+BEGIN_SRC python
     try:
	 Ex = ValueError()
	 Ex.strerror = "La valeur doit être comprise entre 1 et 10."
	 raise Ex
     except ValueError as e:
	 print("Exception ValueError!", e.strerror)
   #+END_SRC

* Créer et utiliser des exceptions personnalisées   

  Python fournit une grande quantité d'exceptions standard que vous
  devriez utiliser chaque fois qu'il est possible. Ces exceptions sont
  incroyablement souples, et vous pouvez même les modifier en fonction
  de vos besoins (dans des limites raisonnables et justifiées, bien
  entendu). Par exemple, la section précédente vous montre comment
  modifier une exception =ValueError= pour afficher des informations
  complémentaires. Cependant, il peut arriver qu'aucune exception
  standard ne réponde à votre problème. Par exemple, le nom de
  l'exception ne dit rien à l'utilisateur qui le renseigne sur ce qui
  se passe. Ou encore, vous travaillez sur une base de données
  spécifique, ou encore avec un certain service. Dans de tels cas,
  vous pouvez donc avoir besoin de créer une exception personnalisée. 

  L'exemple de cette section illustre une méthode rapide pour créer
  vos propres exceptions. Pour cela, vous devez créer une /classe/
  utilisant comme point de départ une exception basée sur les
  fonctionnalités offertes par l'exception =ValueError=. Elle rend
  également l'utilisation de l'exception modifiée plus simple. 

  #+BEGIN_SRC python
    class CustomValueError(ValueError):
	def __init__(self, arg):
	    self.strerror = arg
	    self.args = {arg}


    try:
	raise CustomValueError("La valeur doit être comprise entre 1 et 10.")
    except CustomValueError as e:
	print("Exception CustomValueError!", e.strerror)
  #+END_SRC


  Pour l'essentiel, vous retrouvez ici la fonctionnalité développée
  dans le code de la section << Passer des informations sur une erreur
  à l'appelant >>. Cependant, elle place la même erreur à la fois dans
  =strerror= et dans =args=, de manière à ce que le développeur ait
  accès aux deux (comme cela devrait normalement se produire).

  Le code commence par créer une classe appelée
  =CustomValueError=. Celle-ci prend comme point de départ la valeur
  de l'exception =ValueError=. La fonction =__init__()= fournit le
  moyen de créer une nouvelle instance de cette classe. Vous pourriez
  à ce stade vous figurer une classe comme une sorte de plan
  d'architecte, et l'instance comme le bâtiment construit à partir de
  ce plan.

  L'attribut =strerror= prend la valeur qui lui est directement
  affectée, tandis que =args= la reçoit sous forme d'une chaîne. Le
  membre =args= contient normalement un tableau de toutes les valeurs
  d'exception. Cette procédure est donc standard, même si dans le cas
  présent =args= ne contient qu'une seule valeur.

  Le code servant à utiliser l'exception est ensuite considérablement
  plus simple que la modification directement de la valeur de
  =ValueError=. Tout ce que vous avez à faire, c'est d'appeler =raise=
  avec le nom de l'exception et les arguments que vous voulez lui
  passer. Tout cela tient en une ligne.


* Utiliser la clause finally
  
  Normalement, vous voulez gérer une exception qui se produit sans
  provoquer un plantage de l'application. Cependant, il peut arriver
  que vous ne puissiez rien faire pour réparer les dommages. À ce
  stade, votre objectif devient donc de faire en quelques sorte
  atterrir l'application en douceur, en d'autres termes refermer les
  fichiers qui ont pu être ouverts et effectuer d'autres tâches de
  cette nature. Ceci permet d'éviter d'endommager des données ou de
  laisser le système dans un état instable. Ce qui est le minimum
  qu'on puisse demander à une application...
  
  La clause =finally= fait partie de cette stratégie. Vous l'utilisez
  pour réaliser les tâches essentielles de dernière
  minute. Normalement, cette clause est assez courte et utilise
  uniquement des appels qui sont supposés pouvoir réussir sans poser
  davantage de problèmes. Il est essentiel de refermer les fichiers,
  de déconnecter l'utilisateur, d'effectuer quelques autres tâches
  ménagères, puis de laisser l'application terminer avant qu'il
  n'arrive quelque chose d'absolument terrible (comme un crash violent
  du système). Cette nécessité étant posée, et bien mémorisée dans
  votre esprit, les étapes qui suivent vous propose un exemple simple
  d'utilisation de la clause =finally=.

  #+BEGIN_SRC python
    import sys

    try:
	raise ValueError
	print("Exception levée.")
    except ValueError:
	print("Exception ValueError!")
	sys.exit()
    finally:
	print("Prenez soin des détails de dernière minute.")

    print("Ce code ne sera jamais exécuté.")    
  #+END_SRC


  Dans cet exemple, le code lève une exception =ValueError=. La clause
  =except= s'exécute normalement dans ce genre de
  circonstances. L'appel à =sys.exit()= signifie que l'application se
  termine une fois l'exception gérée. Dans ce cas, la sortie de
  l'application s'effectue directement, ce qui fait que la fonction
  =print()= finale n'est jamais exécutée.

  Le code associé à la clause =finally= est toujours exécuté. Le fait
  que l'exception se produise ou non n'a aucune importance dans ce
  cas. Le code que vous placez dans ce bloc doit donc avoir un
  caractère tout à fait général, puisque vous voulez qu'il soit
  exécuté systématiquement. Par exemple, si vous travaillez avec un
  fichier, vous placerez ici le code qui le referme pour vous assurer
  que les données qu'il contient seront en bon état sur le disque
  dur. 

  
